% Chapter Template

\chapter{Improving the Output} % Main chapter title

\label{Chapter5} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\begin{itemize}
    \item \emph{How to get render the output: what to do?}
    \item \#First, create a simple log
    \item Get the layout
    \item Create dot file of layout
    \item Sort by major and minor events
\end{itemize}

\textbf{Add intro. Why we're doing this, etc.}

\section{Creating a Simple Log}
\begin{itemize}
    \item \#Reasoning behind doing this
    \item \#Loop through file
    \item \#Filter each line, return appropriate line type
    \item \#Print in proper format
    \item   Add issues: LBARD T+ etc.
    \item \#Show development of output format
    \item \#Talk about what events, why they were selected
    \item \#Show output log screenshot
    \item Link with the test - run in the 'finally' section
\end{itemize}

The first step in improving the output of the test framework is improving the log output.
To do this, it was decided that a simple log file should be created for several reasons.
The log files produced by the test framework have a considerable amount of detail contained within them, however this comes at the cost of being incredibly large - even a relatively simple test such as DualType (produced in the previous section) can create log files of 4,000+ lines.
More than that, the log files produced are very difficult to follow, as they are ordered by log file, then chronologically.
Meaning that following a chain of events between multiple nodes becomes a process of consistently switching between sections of log file.
\todo{Add more; formatting, timestamp, etc.}

To fix this, the simple log will require six main features.
\begin{itemize}
    \item Consistent formatting
    \item Chronological ordering by timestamp
    \item Reduce amount of information to only useful info
    \item Machine \emph{and} human readable layout information
    \item Log traceability to original log file
    \item Support all pre-existing topology tests
\end{itemize}


Several options exist for creating a simple log.
The first is to modify the pre-existing codebase of LBARD, Servald, Fakeradio, and the test framework, and modify their logging to meet the above requirements.
This is not considered to be a useful use of this thesis, as this would require changing large parts of the codebase for these programs for a relatively mild improvement, as well as modifying the code of pre-tested and running devices.

The next is to modify the test framework to process and modify the log lines while the tests are run before piping them to the log file.
While this does solve the issue of the previous proposed solution this would add a large amount of bloat to the test framework that is not required in the vast majority of the tests, and may actually prove to be either impossible or vastly difficult using the Shell scripts of the test framework.
Further, this will increase the run-time for tests unnecessarily.

The final option is to write a program that after a test is run and the log file produced, processes the log file and filters and simplifies it, and outputs a separate, simpler log file. 
This is the method that was undertaken in this thesis. 
The program will be written in C as it needs to be fast, portable, and use minimal external dependencies, as well as it is the language that the majority of the Serval codebase is written in - allowing for future developers to easily maintain and improve the code.

As shown in \figurename{ \ref{fig:chapter5SimpleFlowchart}} the program follows a simple structure.
The specified log file is opened, and the first line is read into memory.
This line is then filtered depending on its content; if the line should be in the simple log, and what type of line it is. \todo{Fix this sentence}
The filtered line is then modified to be in a consistent format, and then the formatted line is written to the output simple log file.
The program repeats these steps with each line in the file until it reaches the end of the file.

\begin{figure}
    \begin{centering}
        \includegraphics[width=10cm,height=20cm,keepaspectratio]{Figures/Chapter5-SimpleLogFlowchart.png}
        \caption{Flowchart of creating the simple log}
        \label{fig:chapter5SimpleFlowchart}
    \end{centering}
\end{figure}

\subsection{Filtering Lines}\label{filteringLines}
\begin{itemize}
    \item \#What lines we're selecting
    \item Why they are chosen
\end{itemize}

To ensure that the simple log contains only important lines, the input file needs to be filtered.
Filtering the log file allows for the simple log to contain only lines that are crucial to understanding the operating of the test without overwhelming the person examining the log file.

To determine the minimal information required to understand the tests, the output log files of the tests were analysed.
While analysing the output log files, the following list of important events was created.
\begin{itemize}
    \item \textbf{Setup} Start of a process, lbard/fakeradio
    \item \textbf{Setup} Test details
    \item \textbf{Setup} Layout information (WiFi and Fakeradio)
    \item \textbf{Setup} SID information
    \item \textbf{Servald} Sending and receiving packets
    \item \textbf{Servald} Adding manifest
    \item \textbf{LBARD} Neighbour has a bundle
    \item \textbf{LBARD} Send and receive bundles
    \item \textbf{Fakeradio} Any transfer between two nodes
\end{itemize}
\todo{Add why these were chosen?}
This list covers all major aspects of a topology test; transfer of bundles, setup and layout information, sending and receiving general packets (including the tree-sync packets), and some internal logic and processing when packets are sent and received.
With only these important events, it should be possible to locate and isolate issues related to transferring bundles and packets. 
From there, these filtered events should allow a tester to more easily utilise the vastly more expansive and detailed log file. 


Once the desired events had been determined, these then needed to be filtered within the program.
To achieve this, each line in the file is analysed to determine if it is important by examining what substrings the line contains.
A line is accepted if it matches specified criteria; for instance, a line within the Fakeradio process that contains the substring "neighbour has a bundle" would be considered important.

These lines are then sent to the relevant function to be formatted appropriately.

\subsection{Output format}
\begin{itemize}
    \item \#Original log file format
    \item \#How we get consistent format
    \item \#What the output format is
    \item \#Setup section up top
    \item Getting consistent timestamp (talk about issue with LBARD (. instead of :) T+, etc.)
    \item \#Show a screenshot
\end{itemize}

\subsubsection{Formatting lines}
The log files produced by the test framework follow a consistent structure.
The structure always follows the structure of:
\begin{itemize}
    \item the test details, 
    \item the output of the test framework, 
    \item output of Fakeradio, 
    \item output of \emph{each} LBARD process, and finally,
    \item the output of \emph{each} Servald process.
\end{itemize} 

This structure means that filtering each line becomes far simpler, since we only need to track which process (Fakeradio, LBARD, Servald) we are in, and then filter lines within that process that are relevant.
However the test framework log files have one major issue: the format of lines is not consistent between processes.
For instance, the typical Servald line may look like
\begin{center}
    \begin{lstlisting}[breaklines]
DEBUG:[511710] 18:15:34.372 overlay_mdp.c:859:_overlay_send_frame()  {mdprequests} Send frame 68 bytes    
    \end{lstlisting}
\end{center}
while a similar line in LBARD may look like 

\begin{center}
    \begin{lstlisting}[breaklines]
T+25138ms : Sending length of bundle 6A1A3379501553D1* (bundle #0, version 1596098704035, cached_version 1596098704035)
    \end{lstlisting}
        \todo{Make this font smaller?}
\end{center}


As can be clearly seen, there is a huge difference in format between these two lines, and as such these need to be formatted differently.
To achieve this, when a line is filtered as outlined in the previous section, the program returns an integer value representing the type of line that is to be formatted.
With this information, the appropriate function can be called for the line type, so that it can be formatted correctly.

For Servald lines this becomes trivial, simply use the \verb|sscanf| function to extract the important information from the line, format and write this to a variable using the \verb|sprintf| function, and then write this line to the output file. 
However, in the case of LBARD and Fakeradio lines, multiple issues arise due to the formatting of the log files.
The first of these issues is that several lines in LBARD are not timestamped with the time that they occurred, rather they are timestamped with the number of milliseconds since the program started.
This is an issue since this means that the log files can not be easily sorted by timestamp, and also will not be formatted with a consistent format with the other lines.
To fix this, the time that an LBARD instance is started is logged as this is in a normal timestamp format, and when an event with a 'T+' timestamp occurs, the number of milliseconds is added to the original timestamp to produce a timestamp. 
\todo{Fix these sentences}

The other issue with this method is that Fakeradio log lines often are spread over multiple lines.
This means that simply scanning and processing a single line will not produce all the necessary information.
However, when 
\todo{Finish this}

\todo{Add sorting the output}
\subsubsection{Output log file}

Once the log file is produced it follows a consistent format.
The simple log files format begins with the setup section.
The setup section lists all of the essential information for drawing a diagram of the network topology. 
It lists the test details, SIDs of each of the nodes, and all of the WiFi connections and Fakeradio rules. 
An example of the setup section can be seen in \figurename{ \ref{fig:chapter5SimpleLogSetup}}.

\begin{figure}
    \begin{centering}
        \includegraphics[width=15cm,height=20cm,keepaspectratio]{Figures/Chapter5-SimpleLogSetup.png}
        \caption{Setup section of the simple log}
        \label{fig:chapter5SimpleLogSetup}
    \end{centering}
\end{figure}
After the setup section each line in the log file is ordered by chronological order. 
The lines follow a simple and consistent structure.
\begin{center}
    \begin{lstlisting}[breaklines]
[Timestamp] [Process]:[Instance Letter] [Description]
    \end{lstlisting}
\end{center}
\todo{Maybe have these figures in a lstlisting themselves. Might make the text easier to read?}
This structure can be seen in \figurename{ \ref{fig:chapter5SimpleLogFormat}}
\begin{figure}
    \begin{centering}
        \includegraphics[width=15cm,height=20cm,keepaspectratio]{Figures/Chapter5-SimpleLogFormat.png}
        \caption{Format of simple log events}
        \label{fig:chapter5SimpleLogFormat}
    \end{centering}
\end{figure}





\section{Drawing Packet Transfer through the network}
To improve the output of the test framework, a network diagram displaying packet transfer is highly useful, allowing testers to better understand the topology they are testing. To produce a useful and informative network diagram, four steps need to be undertaken: determine the major events to be displayed on the diagram, create an ASCII representation of the test, generate a network diagram, and finally, create a PDF of the network topology with the traffic displayed.


\begin{itemize}
    \item \#Getting major and minor
    \begin{itemize}
        \item \#As log file is processed, add certain events to major
        \item \#Once we process the log file, sort major and minor
        \item \#Go through stack of (sorted) major, and compare against the time of minor
        \item \#Add minors that are before the major
        \item \#Ends up with a sorted list of major and minor
    \end{itemize}
    \item Create ASCII representation
    \begin{itemize}
        \item Add getting major transfer type
        \item Using sorted list of major, we can iterate through each of the major events
        \item For each minor event, print all the details
    \end{itemize}
    \item Generate network diagrams
    \begin{itemize}
        \item Just the layout
        \item Already written (mostly)
        \item Adding network events
    \end{itemize}
    \item Create PDF of topology
    \begin{itemize}
        \item Adding the images to a LaTeX file
        \item Template or manually?
        \item The layout chosen
        \item For now, manual: easier, however in the future it may be better to have it in a template so layout can be easily changed
        \item Just writing strings to a file
    \end{itemize}
\end{itemize}

\subsection{Getting Major and Minor events}
To create our network diagrams, we first need to determine what will be displayed on the diagram.
To do this, two categories of log messages are defined: 
\begin{itemize}
    \item Major: When two nodes transfer messages
    \item Minor: Some processing on a single Node that would not give the full picture of the test if omitted
\end{itemize}

Major events will be displayed in a diagram showing the network layout, showing the transfer between the two nodes and the message details. 
Minor events however, will be displayed in a list of minor events that occurred before the major event.
There can be multiple minor details per major event, however there is only one major event for each minor event.

There are two options for processing and sorting major and minor events.
The first is to simply process the simple log after it has been made, and check if a line should be considered major or minor. 
The other solution is to classify lines as they are processed in the creation of the simple log.
The second option is quite clearly considerably faster, as in the first option we must re-process a new file and then classify lines within it to be major or minor, however the second option has a major issue in that when lines are classified during the creation of the simple log they are not yet sorted.
This means that if an array of major and minor events is created then these events will \emph{not} be in chronological order.
Unsorted events is a major issue for the creation of diagrams as the created diagrams will quite obviously not be ordered.
This means that for the second option to be considered a method of sorting and \emph{then} assigning minor events to a major event must be developed.
This is the approach that this thesis took.

Determining major events is relatively simple; major events are a transfer between two nodes.
To effectively save major events, a struct defining major events is created.
This struct contains all of the necessary features of a major event. These details are:
\begin{itemize}
    \item Sending Node
    \item Destination Node
    \item Transfer details (type of message, size, etc.)
    \item The time it occurs at
    \item The transfer type (Fakeradio or WiFi)
    \item An array of minor events associated with this major event
\end{itemize}
This occurs at two different points in the log file: when Fakeradio sends a packet to a different node, and when Servald sends a packet.
Fakeradio events are already filtered down to a one line log event for the simple log, so the program simply breaks this line down to get the details of the event, and then appends this to the major events array.
Servald events however are more complicated as the packet transfer takes place over several messages.
To convert this into one event, the program simply saves the details of the packet as each line is processed until the log line stating that the message is sent, at which point all of the saved details are added to an event and appended to the major event array.


To add the minor events, when a line for the simple log is being formatted for the simple log, the program simply checks if it meets a handful of criteria.
The minor events that are filtered include:
\begin{itemize}
    \item Add stuff here
    \item todo
\end{itemize}
\todo{Add the list of filtered things}
\todo{Make all log lines?}
Since the log lines are just a single line, saving these minor events is as simple as appending these lines to the minor event array.


Once the simple log file has been produced, and all major and minor events have been extracted, each minor event needs to be associated with a major event.
When major and minor events are added to their respective arrays, they are done so in the order that the relevant lines appear in the input log file, meaning that these arrays are not sorted.
To associate a minor event with a major event, the minor event must occur before a major event, but \emph{after} the proceeding major event.
To achieve this, both of the arrays must be sorted.
This is simple to achieve using the C standard function \verb|qsort|.
To use this function, a comparator needs to be implemented: that is to say, a function that is able to compare two objects and return a number indicating which object is bigger.
As major events are stored as a struct with a timestamp field the comparator for this is simple to implement; convert the timestamps to a long, and determine which is larger.
For minor events this is similar; extract the timestamp from the message, convert this timestamp to a long, then determine which is larger.
With these comparators implemented, both the major and minor event arrays can be quickly sorted.
Using the sorted arrays, the program is now able to assign minor events to major events.
The process to do this is simple. Iterate through every major event, and check if the top item in the minor events array occurs before the major event.
If it is, then add it to the major event and move to the next minor event. 
Do this for every minor event until a minor event is reached that is after the major event.
At this point, iterate to the next major event and repeat this process.
This is done until all major events have been processed.

The process for combining major and minor events can be seen in \figurename{ \ref{fig:chapter5CombineMajorMinor}}.

With all of the minor events assigned in chronological order to a relevant major event, an ASCII representation of the network traffic throughout the test can be created.

\begin{figure}
    \begin{centering}
        \includegraphics[width=15cm,height=15cm,keepaspectratio]{Figures/Chapter5-CombiningMajorMinor.png}
        \caption{How Major and Minor events are combined}
        \label{fig:chapter5CombineMajorMinor}
    \end{centering}
\end{figure}

\subsection{ASCII Network Traffic}

\subsection{Generating a network diagram}
\todo{Change this to work in new structure}
In the test definitions, it is often difficult to understand what the network topology of a given test is.
This is due to the fact that the topology definitions - while easy to understand for a computer - are not particularly friendly for humans to understand, due to their relatively complicated definition.
The topology definition are split into two section, WiFi and Fakeradio, and lists connections only between two nodes - not the entire network.
\todo{Add more / fix this}
To render these diagrams, the layout will need to be extracted from the test definition, then a diagram drawn of this topology.
From this layout, the image will then need to be created and rendered.
There are two main solutions for creating the image: do it using a graphics library, or creating a DOT file and rendering it with Graphviz.
Using a graphics library would provide a high level of control over the creation of the image as graphical elements would need to be defined explicitly and as such are unlikely to have unforseen side-efects as could be expected with using a higher-level solution such as Graphviz.
That said, this would be considerably more complicated and harder to maintain than simply writing DOT files, then using the high-level tools provided by Graphviz to render this DOT file.
DOT files are text files that follow a specified syntax, and are used by Graphviz to render and create graphs.
These files are simple, and both human and machine readable. 
After weighing these options it was decided that despite the far higher level of control possible by using a low-level graphics library, the simplicity and maintainability of creating and rendering DOT files far outweighs this advantage.

To create the DOT files, minor modifications are needed to be made to the previously implemented line filtering as outlined in section \ref{filteringLines}.
The modifications are simple: when a WiFi or Fakeradio setup line is encountered the node information is stripped from these lines and saved to arrays.
How this is done depends on if it is a WiFi or a Fakeradio line.
For a Fakeradio line the program simply extracts the node numbers \todo{Show example?} from the line, converts these to the appropriate node character, and saves these two variables to a simple struct of just the two node characters.
This struct is appended to an array containing all of the Fakeradio connections.
For a WiFi connection however this is slightly more complicated.
To determine the WiFi topology a 2D array is created.
When a line is encountered that lists a node being connected to a WiFi interface, the node character is appended to the array at the index of the interface.
An example of this data structure can be seen in \figurename{ \ref{fig:chapter5WiFiDataStructure}}, and the resultant network topology in \figurename{ \ref{fig:chapter5ResultWifiTopology}}.

\begin{figure}
    \begin{centering}
        \includegraphics[width=15cm,height=10cm,keepaspectratio]{Figures/Chapter5-WifiArray.png}
        \caption{Data Structure of determining WiFi topology}
        \label{fig:chapter5WiFiDataStructure}
    \end{centering}
\end{figure}

\begin{figure}
    \begin{centering}
        \includegraphics[width=15cm,height=10cm,keepaspectratio]{Figures/Chapter5-WifiArrayResult.png}
        \caption{Resultant WiFi topology of \figurename{ \ref{fig:chapter5WiFiDataStructure}}}
        \label{fig:chapter5ResultWifiTopology}
    \end{centering}
\end{figure}

\begin{itemize}
    \item \#Get layout
    \item \#Decide on DOT file format
    \item Get all combinations of WiFi links
    \item Add to dot file
    \item Render 
    \item Why we're hiding fakeradio/WiFI
    \item   (cos we want to animate, doesn't work otherwise)
    \item Show an output diagram (oooh fancy! pictures!)
\end{itemize}

Once the simple log has finished being generated, the program then moves onto writing the layout DOT file.
The DOT file follows a simple format

\subsection{Creating a LaTeX PDF}
\begin{itemize}
    \item Now that we have an ASCII way of displaying the network, how do we make it nicer?
    \item Create DOT image for transfers
    \begin{itemize}
        \item Pin nodes so they don't move
        \item 
    \end{itemize}
    \item Render every DOT image
    \begin{itemize}
        \item We have an issue with consistent size
        \item So we'll need to right-align everything
        \item Try and make every diagram right-aligned
    \end{itemize}
    \item Create a LaTeX template - work out the layout
    \begin{itemize}
        \item Layout ideas;
        \item Portrait/Landscape
    \end{itemize}
    \item For each major event, render a page of LaTeX
\end{itemize}

\section{Summary}
\textbf{Add link to next section}